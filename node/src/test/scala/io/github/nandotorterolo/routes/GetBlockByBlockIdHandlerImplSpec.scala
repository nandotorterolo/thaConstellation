package io.github.nandotorterolo.routes

import java.security.Security

import cats.data.EitherT
import cats.effect.IO
import io.github.nandotorterolo.crypto.Cripto
import io.github.nandotorterolo.crypto.EcdsaBCEncryption
import io.github.nandotorterolo.models.Account
import io.github.nandotorterolo.models.Address
import io.github.nandotorterolo.models.Block
import io.github.nandotorterolo.models.BlockId
import io.github.nandotorterolo.node.routes.AuthenticationMiddleware
import io.github.nandotorterolo.node.routes.GetBlockByBlockIdHandlerImpl
import io.github.nandotorterolo.node.routes.GetBlockByBlockIdV2HandlerImpl
import io.github.nandotorterolo.server.autogenerated.blockAuthed.BlockAuthedResource
import io.github.nandotorterolo.server.autogenerated.blockAuthedV2.BlockAuthedV2Resource
import io.github.nandotorterolo.server.autogenerated.definitions.BlockResponse
import io.github.nandotorterolo.server.autogenerated.definitions.BlockResponse._
import io.github.nandotorterolo.validators.storageMock
import munit.CatsEffectSuite
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.http4s._
import org.http4s.circe.jsonOf
import org.http4s.headers.Authorization
import org.http4s.headers.Date
import org.http4s.implicits._
import org.typelevel.ci.CIString
import scodec.bits.ByteVector

class GetBlockByBlockIdHandlerImplSpec extends CatsEffectSuite {

  implicit val decoder: EntityDecoder[IO, BlockResponse] = jsonOf[IO, BlockResponse]
  val cripto: Cripto[IO]                                 = EcdsaBCEncryption.build[IO]

  override def beforeAll(): Unit = {
    Security.addProvider(new BouncyCastleProvider())
    ()
  }

  test("Get Block by BlockId returns status code 200, Basic Credentials Middleware") {

    for {
      kp <- cripto.getKeyPair.rethrow

      address = Address(kp.getPublic)
      account = Account(address = address, balance = 0, latestUsedNonce = 0)
      addressIdSigned <- account.address.addressId.sign[IO](kp.getPrivate)(cripto).rethrow

      block = Block(BlockId(ByteVector.fill(20)(0)), 0, Vector.empty)
      blockSigned <- EitherT(block.sign(kp.getPrivate)(cripto)).rethrowT
      blockId = BlockId(blockSigned.hash.value)

      storageMockImpl = storageMock(
        accounts = Map(address.addressId -> account),
        blocks = Map(blockId -> blockSigned)
      )

      authMiddleWare = AuthenticationMiddleware[IO](cripto, storageMockImpl)

      request =
        Request[IO]()
          .withUri(uri"/block" / blockId.value.toBase58)
          .withMethod(Method.GET)
          .withHeaders(
            Headers(
              Authorization(
                BasicCredentials(
                  addressIdSigned.message.value.toBase64,
                  addressIdSigned.encodeToB64.require
                )
              )
            )
          )

      res = new BlockAuthedResource[IO, Account](authMiddleWare.authMiddlewareGuardrail)
        .routes(new GetBlockByBlockIdHandlerImpl(storageMock(blocks = Map(blockId -> blockSigned))))
        .orNotFound(request)

      expected = BlockResponse(
        blockId = blockSigned.hash.value.toBase58,
        priorBlock = blockSigned.message.priorBlock.value.toBase58,
        sequenceNumber = blockSigned.message.sequenceNumber,
        transactions = blockSigned.message.transactions.map(_.value.toBase58).mkString(",")
      )

      _ <- assertIO(res.map(_.status), Status.Ok)

      _ <- assertIO(res.flatMap(_.as[BlockResponse]), expected)
    } yield ()
  }

  /**
   * https://datatracker.ietf.org/doc/html/rfc9421#name-creating-a-signature
   */
  test("Get Block by BlockId returns status code 200, HttpSignatures Middleware RFC 9421".only) {

    for {
      kp <- cripto.getKeyPair.rethrow

      address = Address(kp.getPublic)
      account = Account(address = address, balance = 0, latestUsedNonce = 0)
      addressIdSigned <- account.address.addressId.sign[IO](kp.getPrivate)(cripto).rethrow

      block = Block(BlockId(ByteVector.fill(20)(0)), 0, Vector.empty)
      blockSigned <- EitherT(block.sign(kp.getPrivate)(cripto)).rethrowT
      blockId = BlockId(blockSigned.hash.value)

      storageMockImpl = storageMock(
        accounts = Map(address.addressId -> account),
        blocks = Map(blockId -> blockSigned)
      )

      authMiddleWare = AuthenticationMiddleware[IO](cripto, storageMockImpl)

      date <- HttpDate.current[IO]

      request =
        Request[IO]()
          .withUri(uri"/blockV2" / blockId.value.toBase58)
          .withMethod(Method.GET)
          .withHeaders(
            Headers(
              Header.Raw(CIString("Content-Digest"), s"SHA256withPLAIN-ECDSA=:${addressIdSigned.hash.value.toBase64}:"),
              Date(date),
              Header.Raw(
                CIString("Signature-Input"),
//                s"""sig1=("@method" "@authority" "@path" "content-digest" "content-length" "content-type");created=${date.epochSecond};keyid="${address.addressId.value.toBase64}""""
                s"""sig1=("content-digest");created=${date.epochSecond};keyid="${address.addressId.value.toBase64}""""
              ),
              Header.Raw(CIString("Signature"), s"sig1=:${addressIdSigned.signature.value.toBase64}:"),
            )
          )

      res = new BlockAuthedV2Resource[IO, Account](authMiddleWare.authMiddlewareHttpSignatures)
        .routes(new GetBlockByBlockIdV2HandlerImpl(storageMock(blocks = Map(blockId -> blockSigned))))
        .orNotFound(request)

      expected = BlockResponse(
        blockId = blockSigned.hash.value.toBase58,
        priorBlock = blockSigned.message.priorBlock.value.toBase58,
        sequenceNumber = blockSigned.message.sequenceNumber,
        transactions = blockSigned.message.transactions.map(_.value.toBase58).mkString(",")
      )
      _ <- assertIO(res.map(_.status), Status.Ok)

      _ <- assertIO(res.flatMap(_.as[BlockResponse]), expected)
    } yield ()

  }

}
