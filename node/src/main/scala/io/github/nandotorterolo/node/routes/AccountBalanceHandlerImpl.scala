package io.github.nandotorterolo.node.routes

import cats.data.EitherT
import cats.effect.Async
import cats.implicits._
import fs2.Chunk
import io.github.nandotorterolo.crypto.Cripto
import io.github.nandotorterolo.models.AddressIdSigned
import io.github.nandotorterolo.models.ModelThrowable
import io.github.nandotorterolo.models.ModelThrowable.EntityNotFound
import io.github.nandotorterolo.models.ModelThrowable.InvalidRequestParam
import io.github.nandotorterolo.models.ModelThrowable.Message
import io.github.nandotorterolo.models.ModelThrowable.SignatureValidation
import io.github.nandotorterolo.node.interfaces.StorageService
import io.github.nandotorterolo.server.autogenerated.account.AccountHandler
import io.github.nandotorterolo.server.autogenerated.account.AccountResource
import io.github.nandotorterolo.server.autogenerated.definitions.AccountResponse
import io.github.nandotorterolo.server.autogenerated.definitions.ErrorModel
import org.http4s.Status
import scodec.Codec

/**
 * Generated POST -> Root / "account" / "balance" =>
 */
class AccountBalanceHandlerImpl[F[_]: Async](cripto: Cripto[F], storage: StorageService[F]) extends AccountHandler[F] {

  override def accountDetails(respond: AccountResource.AccountDetailsResponse.type)(body: Chunk[Byte]): F[AccountResource.AccountDetailsResponse] = {
    val response = for {
      addressIdSignedRequest <- EitherT
        .fromEither[F](Codec[AddressIdSigned].decode(body.toBitVector).toEither)
        .leftMap { _ => InvalidRequestParam: ModelThrowable }

      account <- EitherT.fromOptionF(
        storage.getAccount(addressIdSignedRequest.value.message),
        EntityNotFound: ModelThrowable
      )

      publicKey <- EitherT(cripto.publicKey(account.address.publicKey.toArray.toVector))

      _ <- EitherT(addressIdSignedRequest.value.validate[F](publicKey)(cripto))
        .flatMap(isValid =>
          EitherT
            .cond[F](isValid, account, SignatureValidation: ModelThrowable)
        )

    } yield account
    response.value
      .map {
        case Right(a)                  => respond.Ok(AccountResponse(a.address.addressId.value.toBase58, a.balance, a.latestUsedNonce))
        case Left(InvalidRequestParam) => respond.BadRequest(ErrorModel(show"$InvalidRequestParam", Status.BadRequest.code))
        case Left(SignatureValidation) => respond.BadRequest(ErrorModel(show"$SignatureValidation", Status.BadRequest.code))
        case Left(EntityNotFound)      => respond.NotFound(ErrorModel(show"$EntityNotFound", Status.NotFound.code))
        case Left(Message(s))          => respond.InternalServerError(ErrorModel(show"$s", Status.InternalServerError.code))
        case Left(o)                   => respond.InternalServerError(ErrorModel(show"${o.getMessage}", Status.InternalServerError.code))
      }

  }

}
