package io.github.nandotorterolo.node.routes

import scala.util.Try

import cats.data.EitherT
import cats.data.Kleisli
import cats.data.OptionT
import cats.effect.Async
import cats.syntax.all._
import io.github.nandotorterolo.crypto.Cripto
import io.github.nandotorterolo.crypto.Hash
import io.github.nandotorterolo.crypto.Signature
import io.github.nandotorterolo.models.Account
import io.github.nandotorterolo.models.AddressId
import io.github.nandotorterolo.models.AddressIdSigned
import io.github.nandotorterolo.models.ModelThrowable
import io.github.nandotorterolo.models.ModelThrowable.Message
import io.github.nandotorterolo.models.ModelThrowable.SignatureValidation
import io.github.nandotorterolo.node.interfaces.StorageService
import io.github.nandotorterolo.server.autogenerated.blockAuthed.BlockAuthedResource
import io.github.nandotorterolo.server.autogenerated.blockAuthed.BlockAuthedResource.AuthError.Unauthorized
import io.github.nandotorterolo.server.autogenerated.blockAuthed.BlockAuthedResource.AuthSchemes
import io.github.nandotorterolo.server.autogenerated.blockAuthedV2.BlockAuthedV2Resource
import io.github.nandotorterolo.server.autogenerated.blockAuthedV2.BlockAuthedV2Resource.{ AuthSchemes => AuthSchemesV2 }
import io.github.nandotorterolo.server.autogenerated.blockAuthedV2.BlockAuthedV2Resource.AuthError.{ Unauthorized => UnauthorizedV2 }
import org.http4s.dsl.io.Forbidden
import org.http4s.headers.Authorization
import org.http4s.server.AuthMiddleware
import org.http4s.AuthedRoutes
import org.http4s.BasicCredentials
import org.http4s.Request
import org.http4s.Response
import org.typelevel.ci.CIString
import org.typelevel.log4cats.slf4j.Slf4jLogger
import org.typelevel.log4cats.Logger
import scodec.bits.ByteVector

protected final class AuthenticationMiddleware[F[_]: Async](cripto: Cripto[F], storageService: StorageService[F]) {

  implicit val logger: Logger[F] = Slf4jLogger.getLogger[F]

  private val authAccount = Kleisli[F, Request[F], Either[ModelThrowable, Account]] { request =>
    (for {
      authorization <- EitherT.fromEither[F](request.headers.get[Authorization].toRight(Message("Couldn't find an Authorization header"): ModelThrowable))

      (username, password) <- EitherT.fromOption[F](
        BasicCredentials.unapply(authorization.credentials),
        Message("Couldn't parse Basic Credentials"): ModelThrowable
      )
      addressId <-
        EitherT
          .fromEither[F](Try(AddressId(username)).toEither)
          .leftMap(_ => Message("Couldn't create Address Id"): ModelThrowable)

      addressIdSigned <-
        EitherT
          .fromEither[F](AddressIdSigned.fromValidB58(password).toEither)
          .leftMap(_ => Message("Couldn't create AddressSigned Id"): ModelThrowable)

      account <- EitherT.fromOptionF(storageService.getAccount(addressId), Message("Couldn't find an Account"): ModelThrowable)

      publicKey <- EitherT(cripto.publicKey(account.address.publicKey.toArray.toVector))

      _ <- EitherT(addressIdSigned.value.validate[F](publicKey)(cripto))
        .flatMap(b => EitherT.cond[F](b, (), SignatureValidation: ModelThrowable))
    } yield account).value
  }

  private val onFailure = AuthedRoutes[ModelThrowable, F](req => {
    OptionT.liftF(Async[F].delay(Response(Forbidden, body = fs2.Stream.emits(show"${req.context}".getBytes))))
  })

  /**
   * AuthenticationMiddleware
   *
   * A route wrapper with the Authentication Middleware accept authenticated calls.
   * - Header: Authorization: Basic credentials
   * - Credentials: The credentials, encoded according to the specified scheme.
   *
   * - BasicCredentials(addressId: String, addressIdSigned: String)
   *
   * - addressId: An AddressId is defined by a publickKey
   * - addressIdSigned = Signature of the addressId, signed for the Privatekey associated with the PublickKey
   * - usages = BasicCredentials(addressIdSigned.message.value.toBase58, addressIdSigned.encodeToString.require)
   *
   * - result = addressId + ':' + addressIdSigned
   * - Basic credetials must be send as Base 64 encoded string, with a colon between fields
   * - Base64 encodeToString(result)
   *
   * Then a storage Service will find an account with the provided addressId, and will validate the signature using the public key storaged in the server
   */
  val authMiddleware: AuthMiddleware[F, Account] = AuthMiddleware(authAccount, onFailure)

  /**
   * Implementation for auth Middleware using Guardrail Handlers, same implemetation that authMiddleware, using BasicCredentials
   */
  val authMiddlewareGuardrail: (AuthSchemes, Set[String], Request[F]) => F[Either[BlockAuthedResource.AuthError, Account]] = (_, _, request) => {
    (for {

      authorization <- EitherT.fromEither[F](request.headers.get[Authorization].toRight(Unauthorized: BlockAuthedResource.AuthError))

      (username, password) <- EitherT.fromOption[F](
        BasicCredentials.unapply(authorization.credentials),
        Unauthorized: BlockAuthedResource.AuthError
      )

      addressId <-
        EitherT
          .fromEither[F](AddressId.fromValidB64(username).toEither)
          .leftMap(_ => Unauthorized: BlockAuthedResource.AuthError)

      addressIdSigned <-
        EitherT
          .fromEither[F](AddressIdSigned.fromValidB64(password).toEither)
          .leftMap(_ => Unauthorized: BlockAuthedResource.AuthError)

      account <- EitherT.fromOptionF(storageService.getAccount(addressId.value), Unauthorized: BlockAuthedResource.AuthError)

      publicKey <- EitherT(cripto.publicKey(account.address.publicKey.toArray.toVector))
        .leftMap(_ => Unauthorized: BlockAuthedResource.AuthError)

      _ <- EitherT(addressIdSigned.value.validate[F](publicKey)(cripto))
        .leftMap(_ => Unauthorized: BlockAuthedResource.AuthError)
        .flatMap(b => EitherT.cond[F](b, (), Unauthorized: BlockAuthedResource.AuthError))
    } yield account).value

  }

  /**
   * https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures
   *
   * https://datatracker.ietf.org/doc/rfc9421/
   *
   * TODO : continue research HttpSig Authentication for SoLiD, https://github.com/bblfish/authentication-panel/blob/main/proposals/HttpSignature.md
   *
   * - REQUIRED.  The `keyId` field is an opaque string that the server can use to look up the component they need to validate the signature.
   *
   * - REQUIRED.  The `signature` parameter is a base 64 encoded digital signature
   *
   * - RECOMMENDED.  The `algorithm` parameter is used to specify the signature string construction mechanism.
   *
   * - RECOMMENDED.  The `created` field expresses when the signature was created.
   *
   * - OPTIONAL.  The `expires` field expresses when the signature ceases to be valid.
   *
   * - OPTIONAL.  The `headers` parameter is used to specify the list of HTTP headers included when generating the signature for the message.
   *
   * This specification allows the sender to select which headers are meaningful by including their names in the `headers` Signature Parameter.
   *
   * It is out of scope for this document to dictate what header fields an application will want to enforce, but implementers SHOULD at minimum include the `(request-target)` and
   * `(created)` header fields if `algorithm` does not start with `rsa`, `hmac`, or `ecdsa`. Otherwise, `(request-target)` and `date` SHOULD be included in the signature.
   */

  val authMiddlewareHttpSignatures: (AuthSchemesV2, Set[String], Request[F]) => F[Either[BlockAuthedV2Resource.AuthError, Account]] = (_, _, request) => {
    (for {

      signatureInputH <- EitherT.fromEither[F](request.headers.get(CIString("Signature-Input")).toRight(UnauthorizedV2: BlockAuthedV2Resource.AuthError))
      signatureH      <- EitherT.fromEither[F](request.headers.get(CIString("Signature")).toRight(UnauthorizedV2: BlockAuthedV2Resource.AuthError))
      contentDigestH  <- EitherT.fromEither[F](request.headers.get(CIString("Content-Digest")).toRight(UnauthorizedV2: BlockAuthedV2Resource.AuthError))

      // TODO handle structured messages
      _ <- EitherT
        .fromEither[F](io.github.nandotorterolo.headers.Rfc8941.Parser.sfDictionary.parseAll(signatureInputH.head.value))
        .semiflatMap(dict => Logger[F].info(dict.values.mkString))
        .recover(_ => ())
        .leftMap(_ => UnauthorizedV2: BlockAuthedV2Resource.AuthError)

      message <-
        EitherT
          .fromOption[F](
            signatureInputH.head.value
              .split(";")
              .find(_.startsWith("keyid"))
              .map(_.stripPrefix("keyid="))
              // remove first and last '"'
              .map(s => s.substring(1, s.length - 1))
              .flatMap(s => AddressId.fromValidB64(s).toOption),
            UnauthorizedV2: BlockAuthedV2Resource.AuthError
          )

      hash <- EitherT
        .fromEither[F](Try {
          val hashB64 = contentDigestH.head.value.stripPrefix("SHA256withPLAIN-ECDSA=")
          // remove first and last ':'
          Hash(ByteVector.fromValidBase64(hashB64.substring(1, hashB64.length - 1)))

        }.toEither)
        .leftMap(_ => UnauthorizedV2: BlockAuthedV2Resource.AuthError)

      signature <- EitherT
        .fromEither[F](Try {
          val signatureB64 = signatureH.head.value.stripPrefix("sig1=")
          // remove first and last ':'
          Signature(ByteVector.fromValidBase64(signatureB64.substring(1, signatureB64.length - 1)))

        }.toEither)
        .leftMap(_ => UnauthorizedV2: BlockAuthedV2Resource.AuthError)

      account <- EitherT.fromOptionF(storageService.getAccount(message.value), UnauthorizedV2: BlockAuthedV2Resource.AuthError)

      publicKey <- EitherT(cripto.publicKey(account.address.publicKey.toArray.toVector))
        .leftMap(_ => UnauthorizedV2: BlockAuthedV2Resource.AuthError)

      addressIdSigned = AddressIdSigned(hash, signature, message.value)

      _ <- EitherT(addressIdSigned.validate[F](publicKey)(cripto))
        .leftMap(_ => UnauthorizedV2: BlockAuthedV2Resource.AuthError)
        .flatMap(b => EitherT.cond[F](b, (), UnauthorizedV2: BlockAuthedV2Resource.AuthError))
    } yield account).value

  }

}

object AuthenticationMiddleware {

  def apply[F[_]: Async](cripto: Cripto[F], storageService: StorageService[F]) =
    new AuthenticationMiddleware[F](cripto, storageService)
}
